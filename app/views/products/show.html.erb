<div class="col-lg-8 col-lg-offset-2">
	<h2> <%= @product.title %> </h2>
	<!--TODO%= image_tag attachment_url(@product, :image), :style => "max-height: 100%; max-width: 100%;" %-->

	<p class="date">Submitted <%= time_ago_in_words(@product.created_at) %> ago</p> 

	<p class="body"><%= @product.body%></p>

	<div class="btn btn-primary pull-left" data-toggle="modal" data-target="#3Dview">View 3D</div>
	<% if user_signed_in? %>
		<% if current_user.id == @product.user_id %>
			<div class="btn btn-group pull-right">
				<%= link_to "Edit", edit_product_path, :class => "btn btn-default" %>
				<%= link_to "Delete", product_path(@product), method: :delete, data: {confirm: "Are you sure?" }, :class => "btn btn-danger" %>
			</div>
		<% end %>
	<% end %>
	<div class="modal fade" id="3Dview">
		<div class="modal-dialog modal-lg">
			<div class="modal-content">
				<div class="modal-header"><%= @product.title %></div>
				<div class="modal-body" id="canvas"> </div>
				<div class="modal-footer">Click outside this window to close</div>
			</div>
		</div>
	</div>
</div>
<script type="text/javascript">
	var camera, scene, renderer,
	geometry, material, mesh, light1, stats;
	function trim (str) {
		str = str.replace(/^\s+/, '');
		for (var i = str.length - 1; i >= 0; i--) {
			if (/\S/.test(str.charAt(i))) {
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	}
	var parseStlBinary = function(stl) {
		var geo = new THREE.Geometry();
		var dv = new DataView(stl, 80); // 80 == unused header
		var isLittleEndian = true;
		var triangles = dv.getUint32(0, isLittleEndian); 
		var offset = 4;
		for (var i = 0; i < triangles; i++) {
			var normal = new THREE.Vector3(
				dv.getFloat32(offset, isLittleEndian),
				dv.getFloat32(offset+4, isLittleEndian),
				dv.getFloat32(offset+8, isLittleEndian)
			); offset += 12;
			for (var j = 0; j < 3; j++) {
				geo.vertices.push(
					new THREE.Vector3(
						dv.getFloat32(offset, isLittleEndian),
						dv.getFloat32(offset+4, isLittleEndian),
						dv.getFloat32(offset+8, isLittleEndian)
					)
				);
				offset += 12 }
			offset += 2;
			geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
		}
		geo.computeFaceNormals();
		mesh = new THREE.Mesh( 
			geo,
			new THREE.MeshLambertMaterial({
				overdraw:true,
				color: 0x00aa00,
				shading: THREE.FlatShading
			}
		));
		scene.add(mesh);
		stl = null;
	};
	var parseStl = function(stl) {
		var state = '';
		var lines = stl.split('\n');
		var geo = new THREE.Geometry();
		var name, parts, line, normal, done, vertices = [];
		var vCount = 0;
		stl = null;
		for (var len = lines.length, i = 0; i < len; i++) {
			if (done) {
				break;
			}
			line = trim(lines[i]);
			parts = line.split(' ');
			switch (state) {
				case '':
					if (parts[0] !== 'solid') {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "solid"');
						return;
					} else {
						name = parts[1];
						state = 'solid';
					}
					break;
				case 'solid':
					if (parts[0] !== 'facet' || parts[1] !== 'normal') {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "facet normal"');
						return;
					} else {
						normal = [
							parseFloat(parts[2]), 
							parseFloat(parts[3]), 
							parseFloat(parts[4])
						];
						state = 'facet normal';
					}
					break;
				case 'facet normal':
					if (parts[0] !== 'outer' || parts[1] !== 'loop') {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "outer loop"');
						return;
					} else {
						state = 'vertex';
					}
					break;
				case 'vertex': 
					if (parts[0] === 'vertex') {
						geo.vertices.push(new THREE.Vector3(
							parseFloat(parts[1]),
							parseFloat(parts[2]),
							parseFloat(parts[3])
						));
					} else if (parts[0] === 'endloop') {
						geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );
						vCount++;
						state = 'endloop';
					} else {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');
						return;
					}
					break;
				case 'endloop':
					if (parts[0] !== 'endfacet') {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "endfacet"');
						return;
					} else {
						state = 'endfacet';
					}
					break;
				case 'endfacet':
					if (parts[0] === 'endsolid') {
						//mesh = new THREE.Mesh( geo, new THREE.MeshNormalMaterial({overdraw:true}));
						mesh = new THREE.Mesh( 
							geo, 
							new THREE.MeshLambertMaterial({
								overdraw:true,
								color: 0xaa0000,
								shading: THREE.FlatShading
							}
						));
						scene.add(mesh);
						done = true;
					} else if (parts[0] === 'facet' && parts[1] === 'normal') {
						normal = [
							parseFloat(parts[2]), 
							parseFloat(parts[3]), 
							parseFloat(parts[4])
						];
						if (vCount % 1000 === 0) {
							console.log(normal);
						}
						state = 'facet normal';
					} else {
						console.error(line);
						console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');
						return;
					}
					break;
				default:
					console.error('Invalid state "' + state + '"');
					break;
			}
		}
	};
	init();
	animate();
	function init() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 70;
		camera.position.y = 0;
		scene.add( camera );
		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.x = 0; 
		directionalLight.position.y = 0; 
		directionalLight.position.z = 1; 
		directionalLight.position.normalize();
		scene.add( directionalLight );
		var xhr = new XMLHttpRequest();
		xhr.onreadystatechange = function () {
			if ( xhr.readyState == 4 ) {
				if ( xhr.status == 200 || xhr.status == 0 ) {
					var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
					console.log(rep);
					parseStlBinary(rep);
					mesh.rotation.x = 5;
					mesh.rotation.z = .25;
					console.log('done parsing');
				}
			}
		}
		xhr.onerror = function(e) {
			console.log(e);
		}
		xhr.open( "GET", '<%= @product.threeD_model.url %>', true );
		xhr.responseType = "arraybuffer";
		xhr.send( null );
		renderer = new THREE.WebGLRenderer(); //new THREE.CanvasRenderer();
		renderer.setSize(900, 600);
		//renderer.setSize( window.innerWidth, window.innerHeight );
		document.getElementById("canvas").appendChild(renderer.domElement );
		//document.body.appendChild( renderer.domElement );
	}
	function animate() {
		requestAnimationFrame( animate );
		render();
	}
	function render() {
		if (mesh) {
			mesh.rotation.z += 0.02;
		}
		//light1.position.z -= 1;
		renderer.render( scene, camera );
	}
</script>
